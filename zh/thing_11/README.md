#使用域名所属语言编写代码

想象两个代码库。在其中一个例子中，你会遇到：

```
IF(Portfolio IdsByTraderId.get(trader.getID()
.tainsKey(Portfolio.getID(){...}
```

你挠头，想知道这个代码可能是用来做什么的。它似乎是从交易者对象获取ID，使用该ID从地图中获取地图，然后查看内部地图中是否存在来自Portfolio对象的另一个ID。你再抓挠你的头。您可以查看PortfolioIdsByTraderId的声明，并发现以下内容：

```
Map<int，Map<int，int>>PortfolioIdsByTraderId；
```

渐渐地，你会意识到，这可能与一名交易员是否有权投资某一特定投资组合有关。当然，每当有人关心交易员是否有权访问特定投资组合时，你都会找到相同的查找片段-或者更有可能是相似但微妙不同的代码片段。

在另一个代码库中，您会遇到以下代码：

```
If(trader.canView(Portfolio)){...}
```

没有挠头的感觉。你不需要知道交易员是如何知道的。也许有一张这样的地图藏在里面的某个地方。但这是交易员的事，不是你的事。

现在，您更愿意使用这些代码库中的哪一个？

曾几何时，我们只有非常基本的数据结构：位、字节和字符(实际上只有字节，但我们会假装它们是字母和标点符号)。小数有点棘手，因为我们的10进制数字在二进制中不能很好地工作，所以我们有几种大小的浮点类型。然后是数组和字符串(实际上只是不同的数组)。然后我们有堆栈、队列、散列、链表、跳过列表和许多其他令人兴奋的数据结构*这些在现实世界中是不存在的*。“计算机科学”指的是花费大量精力将现实世界映射到我们的限制性数据结构中。真正的上师甚至还记得他们是如何做到的。

然后我们就有了用户定义的类型！好吧，这不是新闻，但它确实在一定程度上改变了游戏规则。如果您的域包含像交易者和投资组合这样的概念，您可以用称为交易者和投资组合的类型对它们进行建模。但是，更重要的是，您还可以使用领域术语对它们之间的*关系进行建模。

如果你不使用领域术语编码，你就是在创建一种默契(阅读：秘密)，理解这里的这个*int意味着识别交易者的方式，而那里的*那个*int意味着识别投资组合的方式。(最好不要把它们弄混！)如果你用一个算法片段来表示一个业务概念(“有些交易员不被允许查看某些投资组合--这是非法的”)，比如关键字映射中的存在关系，那么你并没有给审计和合规人员带来任何好处。

下一个程序员可能不知道这个秘密，所以为什么不明确一点呢？使用一个键作为对执行存在检查的另一个键的查找并不是非常明显。人们应该如何直觉地认为，这就是防止利益冲突的业务规则的实施之处？

在您的代码中明确域概念意味着其他程序员可以更容易地收集代码的*意图*，而不是试图将算法改造为他们对域的理解。这还意味着当域模型发展时--随着您对领域的理解的增长，它将会发展--您就处于一个很好的位置来发展代码。再加上良好的封装，规则很有可能只存在于一个位置，并且您可以更改它，而不需要任何依赖代码。

几个月后来编写代码的程序员会感谢您的。几个月后出现的程序员可能就是你。

作者：[Dan North](http://programmer.97things.oreilly.com/wiki/index.php/Dan_North)