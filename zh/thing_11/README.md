# 使用领域语言编写代码

想象一下两个代码库。在其中一个代码库中，你遇到了以下代码：

```
if (portfolioIdsByTraderId.get(trader.getId())
  .containsKey(portfolio.getId())) {...}
```

你挠了挠头，想知道这段代码可能是用来做什么的。它似乎是从一个交易员对象中获取一个ID，然后用这个ID从一个看起来像是“映射的映射”中获取另一个映射，接着检查一个投资组合对象中的ID是否存在于这个内部映射中。你再次挠了挠头。你查找了`portfolioIdsByTraderId`的声明，发现了这个：

```
Map<int, Map<int, int>> portfolioIdsByTraderId;
```

渐渐地，你意识到这可能与某个交易员是否有权访问某个特定的投资组合有关。当然，你会在任何需要判断交易员是否有权访问某个投资组合的地方找到相同的查找片段——或者更可能是类似但略有不同的代码片段。

在另一个代码库中，你遇到了这段代码：

```
if (trader.canView(portfolio)) {...}
```

不需要挠头。你不需要知道交易员是如何知道的。也许在某个地方藏着一个这样的“映射的映射”。但那是交易员的事情，不是你的事情。

现在，你更愿意在哪个代码库中工作呢？

曾经，我们只有非常基础的数据结构：位、字节和字符（实际上只是字节，但我们假装它们是字母和标点符号）。十进制数有点棘手，因为我们的十进制数字在二进制中表现不佳，所以我们有几种不同大小的浮点类型。然后是数组和字符串（实际上只是不同类型的数组）。接着我们有了栈、队列、哈希表、链表、跳表以及许多其他令人兴奋的数据结构*这些在现实世界中并不存在*。“计算机科学”就是花大量精力将现实世界映射到我们有限的数据结构中。真正的专家甚至能记住他们是如何做到的。

然后我们有了用户定义的类型！好吧，这并不是什么新鲜事，但它确实在某种程度上改变了游戏规则。如果你的领域中包含像交易员和投资组合这样的概念，你可以用名为`Trader`和`Portfolio`的类型来建模。但更重要的是，你也可以使用领域术语来建模*它们之间的关系*。

如果你不使用领域术语编写代码，你就是在创建一个隐含的（或者说秘密的）理解：*这个*`int`表示识别交易员的方式，而*那个*`int`表示识别投资组合的方式。（最好不要把它们搞混！）如果你用一个算法片段（比如一个键映射中的存在关系）来表示一个业务概念（“某些交易员不允许查看某些投资组合——这是非法的”），你并没有为审计和合规团队提供任何便利。

下一个程序员可能并不知道这个秘密，所以为什么不把它明确化呢？使用一个键来查找另一个键以执行存在性检查并不是非常直观。别人怎么能直觉地认为这就是防止利益冲突的业务规则的实现之处呢？

在代码中明确表达领域概念意味着其他程序员可以更容易地理解代码的*意图*，而不必试图将算法与他们所理解的领域知识进行匹配。这也意味着当领域模型演化时——随着你对领域的理解加深，它必然会演化——你处于一个有利的位置来演化代码。结合良好的封装，规则很可能只存在于一个地方，并且你可以在不影响依赖代码的情况下进行更改。

几个月后接手这段代码的程序员会感谢你。几个月后接手这段代码的程序员可能就是你。

作者：[Dan North](http://programmer.97things.oreilly.com/wiki/index.php/Dan_North)