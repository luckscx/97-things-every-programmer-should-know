#单一责任原则

好的设计最基本的原则之一是：

>将因同一原因而改变的集合在一起，将因不同原因而改变的事物分开。

这一原则通常被称为“单一责任原则”或SRP。简而言之，它说一个子系统、模块、类，甚至一个函数，不应该有一个以上的更改原因。典型的示例是具有处理业务规则、报告和数据库的方法的类：

```
公共班级员工{
公款计算Pay()...
公共字符串reportHour()...
PUBLIC VALID SAVE()...
}
```

一些程序员可能认为将这三个函数放在同一个类中是非常合适的。毕竟，类应该是对公共变量进行操作的函数的集合。然而，问题是，这三个功能的变化是出于完全不同的原因。每当计算工资的业务规则发生变化时，`culatePay`函数就会发生变化。每当有人想要不同的报告格式时，`reportHours`函数就会改变。每当DBA更改数据库模式时，SAVE函数都会更改。这三个改变的原因加在一起，让“雇员”变得非常不稳定。它会因为这些原因中的任何一个而改变。更重要的是，任何依赖于`Employee‘的类都将受到这些更改的影响。

好的系统设计意味着我们将系统分成可以独立部署的组件。独立部署意味着，如果我们更改一个组件，则不必重新部署任何其他组件。然而，如果其他组件中的许多其他类大量使用`Employee`，那么对Employee的每一次更改都可能导致其他组件被重新部署；从而否定了组件设计的主要好处(如果您更喜欢更时髦的名称，则可以使用SOA)。

```
公共班级员工{
公款计算Pay()...
}

公共类EmployeeReporter{
公共字符串reportHour(Employee)...
}

公共类EmployeeRepository{
公共无效保存(员工e)...
}
```

上面显示的简单分区解决了这些问题。这些类中的每一个都可以放置在它自己的组件中。或者更确切地说，所有报告类都可以进入报告组件。所有与数据库相关的类都可以放入存储库组件中。并且所有业务规则都可以放入业务规则组件中。

精明的读者会发现上述解决方案中仍然存在依赖关系。那个‘雇员’仍然依赖于其他阶级。因此，如果修改`Employee`，其他类很可能需要重新编译和重新部署。因此，`Employee`不能修改后再独立部署。但是，其他类可以修改并独立部署。对其中任何一个的修改都不能强制重新编译或重新部署其他任何一个。甚至可以通过谨慎使用*依赖反转原理*(DIP)来独立部署`Employee‘，但这是[另一本书](http://www.amazon.com/dp/0135974445/).)的主题

仔细应用SRP，将因不同原因而改变的事物分开，是创建具有独立可部署组件结构的设计的关键之一。

作者：[Bob](http://programmer.97things.oreilly.com/wiki/index.php/Uncle_Bob)叔叔
