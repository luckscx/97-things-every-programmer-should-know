#表演之路布满了肮脏的代码炸弹

通常情况下，性能调优系统需要您更改代码。当我们需要修改代码时，每个过于复杂或高度耦合的块都是一个肮脏的代码炸弹，等待着破坏这一努力。肮脏代码的第一个受害者将是您的日程安排。如果前进的道路是平坦的，就很容易预测你什么时候会完成。与肮脏代码的意外相遇将使我们很难做出合理的预测。

考虑一下您找到执行热点的情况。正常的做法是降低底层算法的强度。假设您对经理提出的评估请求作出答复，回答时间为3-4小时。当你应用修复程序时，你很快就会意识到你已经破坏了依赖的部分。由于密切相关的事物往往是必然耦合的，这种破坏很可能是意料之中的，也是可以解释的。但是，如果修复依赖关系会导致其他依赖部分中断，会发生什么情况呢？此外，依赖关系离来源越远，你就越不可能认识到它是这样的，并在你的估计中考虑到它。突然之间，你3-4小时的预估很容易膨胀到3-4周。通常，日程表中的这种意外膨胀一次发生一到两天。“快速”重构最终需要几个月才能完成的情况并不少见。在这些情况下，对负责任团队的信誉和政治资本造成的损害将从严重到致命。如果我们有一种工具来帮助我们识别和衡量这种风险就好了。

事实上，我们有很多方法来测量和控制代码的耦合程度和深度以及复杂性。软件度量可以用来计算代码中特定功能的出现次数。这些计数的值确实与代码质量相关。衡量耦合的许多指标中有两个是扇入和扇出。考虑类的扇出：它被定义为直接或间接从感兴趣的类引用的类的数量。您可以将其视为在编译类之前必须编译的所有类的计数。另一方面，扇入是依赖于感兴趣的类的所有类的计数。已知扇出和扇入，我们可以使用*i=f<sup>i</sup><sup>i</sup>+f<sup>i</sup><sup>i</sup>+<sup>f</sup><sup>i</sup><sup>i</sup>/<sup>i</sup>/<sup>i</sup>来计算不稳定因子。当*i*接近0时，包变得更稳定。当*i*接近1时，包变得不稳定。稳定的包是重新编码的低风险目标，而不稳定的包更有可能充满肮脏的代码炸弹。重构的目标是使*i*更接近于0。

在使用指标时，必须记住它们只是经验法则。纯粹在数学上，我们可以看到，在不改变fo的情况下，增加*f<Sub>i</Sub>*会使*i*更接近于0。然而，一个非常大的扇入值也有一个不利之处，因为在不破坏依赖项的情况下，这些类将更难更改。此外，如果不解决分散问题，你就不能真正降低风险，因此必须应用一些平衡。

软件指标的一个缺点是，指标工具产生的大量数字可能会让外行望而生畏。也就是说，在我们争取干净代码的斗争中，软件度量可以成为一个强大的工具。它们可以帮助我们在脏代码炸弹对性能调优练习造成严重风险之前识别和消除它们。

作者：[Kirk Pepperdine](http://programmer.97things.oreilly.com/wiki/index.php/Kirk_Pepperdine)