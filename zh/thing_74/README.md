# 性能优化之路布满“脏代码炸弹”

通常情况下，优化系统性能需要修改代码。当我们需要修改代码时，每一块过于复杂或高度耦合的代码都是一个潜在的“脏代码炸弹”，随时可能破坏我们的优化工作。脏代码的第一个受害者将是你的时间表。如果前进的道路是平坦的，那么预测完成时间将很容易。然而，意外遇到脏代码会使预测变得非常困难。

考虑这样一种情况：你发现了一个执行热点。通常的做法是降低底层算法的复杂度。假设你向经理估计需要3-4小时来完成这个修复。当你开始应用这个修复时，你很快意识到你破坏了一个依赖部分。由于紧密相关的事物通常必然耦合，这种破坏很可能是预料之中的，并且已经考虑在内。但如果修复这个依赖导致其他依赖部分也出现问题呢？此外，依赖关系离源头越远，你越不可能意识到它，并在你的估计中考虑它。突然间，你的3-4小时估计很容易膨胀到3-4周。通常，这种时间表的意外膨胀每次会持续1到2天。常见的“快速”重构最终可能需要几个月才能完成。在这些情况下，负责团队的信誉和政治资本将受到严重甚至致命的损害。如果我们有一个工具来帮助我们识别和衡量这种风险就好了。

事实上，我们有很多方法来衡量和控制代码的耦合度和复杂度。软件度量可以用来计算代码中特定特征的出现次数。这些计数值与代码质量相关。衡量耦合度的两个度量指标是扇入和扇出。以类的扇出为例：它被定义为从感兴趣的类直接或间接引用的类的数量。你可以将其视为在编译你的类之前必须编译的所有类的数量。另一方面，扇入是所有依赖于感兴趣类的类的数量。知道扇出和扇入后，我们可以使用公式 *I = f<sub>o</sub> / (f<sub>i</sub> + f<sub>o</sub>)* 来计算一个不稳定因子。当 *I* 接近0时，包变得更加稳定。当 *I* 接近1时，包变得不稳定。稳定的包是低风险的重新编码目标，而不稳定的包更可能充满脏代码炸弹。重构的目标是将 *I* 移近0。

在使用度量时，必须记住它们只是经验法则。从数学上讲，我们可以看到在不改变 *f<sub>o</sub>* 的情况下增加 *f<sub>i</sub>* 会使 *I* 接近0。然而，非常大的扇入值也有一个缺点，即这些类在不破坏依赖项的情况下更难修改。此外，如果不解决扇出问题，你并没有真正降低风险，因此必须应用一些平衡。

软件度量的一个缺点是，度量工具产生的大量数字可能会让不熟悉的人感到畏惧。尽管如此，软件度量可以成为我们在追求干净代码的过程中一个强大的工具。它们可以帮助我们在脏代码炸弹对性能优化工作构成严重风险之前识别并消除它们。

作者：[Kirk Pepperdine](http://programmer.97things.oreilly.com/wiki/index.php/Kirk_Pepperdine)