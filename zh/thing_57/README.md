#消息传递在并行系统中带来更好的可扩展性

程序员从学习计算的一开始就被教导，并发性--尤其是并行性的一个特殊子集--是很难的，只有最优秀的人才能希望把它做对，即使他们也做错了。总是非常关注线程、信号量、监视器，以及使对变量的并发访问保持线程安全有多难。

诚然，有很多困难的问题，而且它们可能很难解决。但问题的根源是什么呢？共享内存。人们不断讨论的几乎所有并发问题都与共享可变内存的使用有关：竞争条件、死锁、活锁等。答案似乎很明显：要么放弃并发，要么避免共享内存！

放弃并发性几乎肯定不是一种选择。计算机几乎每个季度都有越来越多的核心，因此利用真正的并行性变得越来越重要。我们不能再依赖不断提高的处理器时钟速度来提高应用程序性能。只有利用并行性才能提高应用程序的性能。显然，不提高性能是一种选择，但它不太可能被用户接受。

那么，我们可以避免共享内存吗？一定。

我们可以使用进程和消息传递，而不是使用线程和共享内存作为编程模型。这里的进程只是指具有执行代码的受保护的独立状态，不一定是操作系统进程。Erlang(以及之前的Occam)等语言已经表明，进程是一种非常成功的并发和并行系统编程机制。这样的系统没有共享内存、多线程系统所具有的所有同步压力。此外，还有一个正式的模型--通信顺序进程(CSP)--可以作为此类系统工程的一部分来应用。

我们可以更进一步，引入数据流系统作为一种计算方式。在数据流系统中，没有显式编程的控制流。取而代之的是建立由数据路径连接的操作员的有向图，然后将数据反馈到系统中。评估受系统内数据准备情况的控制。绝对没有同步问题。

话虽如此，C、C++、Java、Python和Groovy等语言是系统开发的主要语言，所有这些语言都是作为开发共享内存、多线程系统的语言呈现给程序员的。那么我们能做些什么呢？答案是使用-或者，如果它们不存在，创建-提供流程模型和消息传递的库和框架，避免所有共享可变内存的使用。

总而言之，不是使用共享内存编程，而是使用消息传递，很可能是实现利用计算机硬件中目前普遍存在的并行性的系统的最成功方式。也许奇怪的是，尽管进程早于线程作为并发单位，但未来似乎是使用线程来实现进程。

作者：[Russel Winder](http://programmer.97things.oreilly.com/wiki/index.php/Russel_Winder)