# 消息传递在并行系统中带来更好的可扩展性

程序员从学习计算机的一开始就被教导并发——尤其是并行性，并发的一个特殊子集——是困难的，只有最优秀的人才能希望把它做好，而即使是他们也常常出错。人们总是非常关注线程、信号量、监视器，以及如何使变量的并发访问变得线程安全。

确实，存在许多难题，它们可能非常难以解决。但问题的根源是什么？共享内存。几乎所有人们反复讨论的并发问题都与共享可变内存的使用有关：竞态条件、死锁、活锁等。答案似乎显而易见：要么放弃并发，要么避免共享内存！

放弃并发几乎肯定不是一个选项。计算机几乎每季度都有越来越多的核心，因此利用真正的并行性变得越来越重要。我们不能再依赖处理器时钟速度的不断提高来提高应用程序性能。只有通过利用并行性，应用程序的性能才能提高。显然，不提高性能也是一种选择，但这不太可能被用户接受。

那么，我们能避免共享内存吗？当然可以。

我们可以使用进程和消息传递，而不是使用线程和共享内存作为我们的编程模型。这里的进程仅仅意味着一个受保护的独立状态和执行代码，不一定是操作系统进程。像Erlang（以及之前的occam）这样的语言已经表明，进程是编程并发和并行系统的一个非常成功的机制。这样的系统没有共享内存、多线程系统所具有的所有同步压力。此外，还有一个形式化模型——通信顺序进程（CSP）——可以作为此类系统工程的一部分应用。

我们可以更进一步，引入数据流系统作为一种计算方式。在数据流系统中，没有显式编程的控制流。相反，建立了一个由数据路径连接的操作符的有向图，然后将数据输入系统。评估由系统中数据的准备情况控制。绝对没有同步问题。

尽管如此，像C、C++、Java、Python和Groovy这样的语言是系统开发的主要语言，所有这些语言都被呈现给程序员，作为开发共享内存、多线程系统的语言。那么我们能做些什么呢？答案是使用——或者如果它们不存在，就创建——提供进程模型和消息传递的库和框架，避免使用共享可变内存。

总的来说，不使用共享内存编程，而是使用消息传递，可能是实现利用计算机硬件中普遍存在的并行性的系统的最成功的方式。也许奇怪的是，尽管进程作为并发单位早于线程，但未来似乎在于使用线程来实现进程。

作者：[Russel Winder](http://programmer.97things.oreilly.com/wiki/index.php/Russel_Winder)