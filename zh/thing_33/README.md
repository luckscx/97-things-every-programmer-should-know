# 浮点数不是实数

浮点数在数学意义上并不是“实数”，尽管在某些编程语言（如Pascal和Fortran）中它们被称为*实数*。实数具有无限精度，因此是连续且无损的；而浮点数精度有限，所以它们是有限的，并且类似于“表现不佳”的整数，因为它们在范围内并不是均匀分布的。

举个例子，将2147483647（最大的32位有符号整数）赋值给一个32位浮点变量（比如x），然后打印它。你会看到2147483648。现在打印`x - 64`，结果仍然是2147483648。再打印`x - 65`，你会得到2147483520！为什么会这样？因为在该范围内相邻浮点数之间的间距是128，而浮点运算会四舍五入到最接近的浮点数。

IEEE浮点数是基于二进制科学计数法的固定精度数字：1.d<sub>1</sub>d<sub>2</sub>...d<sub>p-1</sub> × 2<sup>e</sup>，其中*p*是精度（float为24，double为53）。两个连续数字之间的间距是2<sup>1-p+e</sup>，可以安全地近似为ε|x|，其中ε是*机器epsilon*（2<sup>1-p</sup>）。

了解浮点数附近的间距可以帮助你避免经典的数值错误。例如，如果你正在执行迭代计算，比如寻找方程的根，那么要求比数字系统在答案附近所能提供的更高精度是没有意义的。确保你请求的容差不小于该处的间距；否则你将永远循环下去。

由于浮点数是实数的近似值，不可避免地会存在一些误差。这种误差称为*舍入误差*，可能会导致令人惊讶的结果。例如，当你减去几乎相等的数字时，最高有效位会相互抵消，因此原本是最低有效位（舍入误差所在的位置）会被提升到浮点结果中的最高有效位，从而基本上污染了任何进一步的相关计算（这种现象称为*涂抹*）。你需要仔细检查你的算法，以防止这种*灾难性抵消*。举个例子，考虑用二次公式求解方程*x<sup>2</sup> - 100000x + 1 = 0*。由于表达式*-b + sqrt(b<sup>2</sup> - 4)*中的操作数在数量级上几乎相等，你可以改为计算根*r<sub>1</sub> = -b + sqrt(b<sup>2</sup> - 4)*，然后得到*r<sub>2</sub> = 1/r<sub>1</sub>*，因为对于任何二次方程ax<sup>2</sup> + bx + c = 0，根满足*r<sub>1</sub>r<sub>2</sub> = c/a*。

涂抹可能以更微妙的方式发生。假设一个库天真地通过公式*1 + x + x<sup>2</sup>/2 + x<sup>3</sup>/3! + ...*计算*e<sup>x</sup>*。这对于正数*x*效果很好，但考虑一下当*x*是一个大的负数时会发生什么。偶数幂项会产生大的正数，而减去奇数幂的数量级甚至不会影响结果。这里的问题在于，大的正数项中的舍入误差位于比真实答案更重要的数字位置。答案会趋向于正无穷！这里的解决方案也很简单：对于负数*x*，计算*e<sup>x</sup> = 1/e<sup>|x|</sup>*。

不言而喻，你不应该将浮点数用于金融应用——这正是Python和C#等语言中的十进制类的用途。浮点数旨在用于高效的科学计算。但如果没有准确性，效率就毫无价值，所以请记住舍入误差的来源，并相应地编写代码！

作者：[Chuck Allison](http://programmer.97things.oreilly.com/wiki/index.php/Chuck_Allison)