#浮点数不是实数

浮点数并不是数学意义上的“实数”，尽管它们在一些编程语言中被称为“实数”，例如Pascal和Fortran。实数有无限的精度，因此是连续和无损的；浮点数的精度是有限的，所以它们是有限的，它们类似于“行为不佳”的整数，因为它们在整个范围内不是均匀分布的。

为了进行说明，将2147483647(最大的有符号32位整数)赋给一个32位浮点变量(比如x)，然后打印出来。你会看到2147483648。现在打印`x-64`。仍然是2147483648。现在打印‘x-65’，你会得到2147483520！为什么？因为在该范围内相邻浮点数之间的间距是128，并且浮点运算舍入到最接近的浮点数。

IEEE浮点数是基于二进制科学记数法的固定精度数字：1.d<sub>1</sub>d<sub>2</sub>...d<sub>p-1</sub>×2<sup>e</sup>，其中*p*是精度(24表示浮点数，53表示双精度)。两个连续数字之间的间距为2<sup>1-p+e</sup>，可以用ε|x|安全地近似，其中ε是*机器epsilon*(2<sup>1-p</sup>)。

了解浮点数附近的间距可以帮助您避免典型的数值错误。例如，如果您正在执行迭代计算，例如搜索方程的根，那么要求比数值系统在答案附近给出的精度更高的精度是没有意义的。确保您要求的公差不小于那里的间距；否则，您将永远循环。

由于浮点数是实数的近似值，因此不可避免地会出现一些误差。这种称为“四舍五入”的误差可能会导致令人惊讶的结果。例如，当您减去几乎相等的数字时，最高有效位相互抵消，因此最低有效位(舍入误差所在的位置)将提升到浮点结果中的最高有效位置，基本上会影响任何进一步的相关计算(这种现象称为*涂抹*)。你需要仔细检查你的算法，以防止这种*灾难性的取消*。为了说明，考虑用二次公式求解方程*x<sup>2</sup>-100000x+1=0*。由于表达式*-b+sqrt(b<sup>2</sup>-4)*中的操作数大小几乎相等，因此您可以改为计算根*r<sub>1</sub>=-b+sqrt(b<sup>2</sup>-4)*，然后获得*r<sub>2</sub>=1/r<sub>1</sub>*，因为对于任何二次方程，ax2+bx+c=0，根都满足*r<sub>1</sub>2</sub>=c/a*。

涂抹可以以更微妙的方式发生。假设一个库通过公式*1+x+x<sup>2/2+x<sup>3</sup>/3！+...*简单地计算*e<sup>x</sup>*。这对于正*x*很好，但是考虑一下当*x*是一个很大的负数时会发生什么。偶数次方的项产生很大的正数，减去奇数次方的大小甚至不会影响结果。这里的问题是，大的、正的取整处于比真实答案重要得多的数字位置。答案朝着正无穷大发散！这里的解决方案也很简单：对于负*x*，计算*e<sup>x</sup>=1/e<sup>|x|</sup>*。

不用说，您不应该在金融应用程序中使用浮点数--这就是像Python和C#这样的语言中的十进制类的用途。浮点数旨在用于高效的科学计算。但是，如果没有精度，效率就毫无价值，因此请记住舍入误差的来源并相应地编写代码！

作者：[Chuck Allison](http://programmer.97things.oreilly.com/wiki/index.php/Chuck_Allison)