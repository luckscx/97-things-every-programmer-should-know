#进程间通信影响应用程序响应时间

响应时间对软件可用性至关重要。很少有事情像等待某个软件系统做出反应那样令人沮丧，特别是当我们与软件的交互涉及刺激和反应的重复循环时。我们觉得这个软件好像在浪费我们的时间，影响我们的工作效率。然而，响应时间不佳的原因没有得到很好的理解，特别是在现代应用程序中。许多性能管理文献仍然集中在数据结构和算法上，这些问题在某些情况下可能会有所不同，但在现代多层企业应用程序中不太可能主导性能。

当这类应用程序的性能是一个问题时，我的经验是，检查数据结构和算法并不是寻找改进的正确地方。响应时间在很大程度上取决于响应于刺激而进行的远程进程间通信(IPC)的数量。虽然可能存在其他本地瓶颈，但远程进程间通信的数量通常占主导地位。每个远程进程间通信都会对总体响应时间造成一些不可忽略的延迟，这些影响加在一起，特别是当它们是按顺序发生的时候。

一个最好的例子是使用对象关系映射的应用程序中的“涟漪加载”。涟漪加载描述了许多数据库调用的顺序执行，以选择构建对象图所需的数据(参见Martin Fowler的*Patterns of Enterprise Application Architecture中的Lazy Load](http://martinfowler.com/eaaCatalog/lazyLoad.html))。当数据库客户端是呈现网页的中间层应用程序服务器时，这些数据库调用通常在单个线程中顺序执行。它们各自的延迟会累积起来，从而影响总体响应时间。即使每个数据库调用只需要10毫秒，一个需要1000个调用的页面(这并不少见)将显示至少10秒的响应时间。其他示例包括Web服务调用、来自Web浏览器的HTTP请求、分布式对象调用、请求-回复消息传递以及基于自定义网络协议的数据网格交互。对刺激做出反应所需的远程IPC越多，响应时间就越长。

对于减少每个刺激的远程进程间通信的数量，有一些相对明显和众所周知的策略。一种策略是应用简约原则，优化流程之间的接口，以便以最少的交互准确地交换手头目标的正确数据。另一种策略是尽可能将进程间通信并行化，以便总体响应时间主要由延迟时间最长的IPC驱动。第三种策略是缓存以前的IPC的结果，这样可以通过命中本地缓存来避免未来的IPC。

在设计应用程序时，要注意响应每个刺激的进程间通信的数量。在分析性能较差的应用程序时，我经常发现IPC与刺激的比率为数千：1。降低这一比率，无论是通过缓存、并行化还是其他一些技术，将比更改数据结构选择或调整排序算法带来的回报要大得多。

作者：[Randy Stafford](http://programmer.97things.oreilly.com/wiki/index.php/Randy_Stafford)