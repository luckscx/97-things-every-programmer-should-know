# 进程间通信影响应用程序响应时间

响应时间对软件可用性至关重要。没有什么比等待某个软件系统响应更令人沮丧的了，尤其是当我们与软件的交互涉及反复的刺激和响应循环时。我们感觉软件在浪费我们的时间，影响我们的工作效率。然而，导致响应时间不佳的原因却鲜为人知，尤其是在现代应用程序中。许多性能管理文献仍然关注数据结构和算法，这些问题在某些情况下可能会产生影响，但在现代多层企业应用程序中，它们不太可能主导性能。

当这类应用程序出现性能问题时，我的经验是，检查数据结构和算法并不是寻找改进的正确方向。响应时间主要取决于响应刺激时进行的远程进程间通信（IPC）的数量。虽然可能存在其他本地瓶颈，但远程进程间通信的数量通常占主导地位。每次远程进程间通信都会为整体响应时间增加一些不可忽视的延迟，这些单独的延迟会累积起来，尤其是在它们按顺序发生时。

一个典型的例子是使用对象-关系映射的应用程序中的*涟漪加载*。涟漪加载描述了为构建对象图而执行的许多数据库调用的顺序执行（参见Martin Fowler的《企业应用架构模式》中的[Lazy Load](http://martinfowler.com/eaaCatalog/lazyLoad.html)）。当数据库客户端是呈现网页的中间层应用服务器时，这些数据库调用通常在一个线程中顺序执行。它们的单独延迟会累积，从而影响整体响应时间。即使每个数据库调用只需要10毫秒，一个需要1000次调用的页面（这并不罕见）也会表现出至少10秒的响应时间。其他例子包括Web服务调用、来自Web浏览器的HTTP请求、分布式对象调用、请求-回复消息传递以及通过自定义网络协议进行的数据网格交互。响应刺激所需的远程IPC越多，响应时间就越长。

有一些相对明显且众所周知的策略可以减少每次刺激的远程进程间通信数量。一种策略是应用简约原则，优化进程之间的接口，以便以最少的交互量交换当前所需的精确数据。另一种策略是尽可能并行化进程间通信，从而使整体响应时间主要由延迟最长的IPC决定。第三种策略是缓存先前IPC的结果，以便通过命中本地缓存来避免未来的IPC。

在设计应用程序时，请注意响应每个刺激的进程间通信数量。在分析性能不佳的应用程序时，我经常发现IPC与刺激的比例高达数千比一。通过缓存、并行化或其他技术来降低这一比例，将比更改数据结构选择或调整排序算法带来更大的回报。

作者：[Randy Stafford](http://programmer.97things.oreilly.com/wiki/index.php/Randy_Stafford)