# 用理性编码

尝试手动推理软件的正确性会导致形式化证明比代码本身更长，并且比代码更容易包含错误。自动化工具是更好的选择，但并不总是可行的。以下描述了一种中间路径：半正式地推理正确性。

基本方法是将所有考虑的代码划分为短小的部分——从单行代码（如函数调用）到少于十行的代码块——并论证它们的正确性。这些论证只需要足够强有力，以说服你那位持怀疑态度的同行程序员。

选择的部分应确保在每个端点处，*程序的状态*（即程序计数器和所有“存活”对象的值）满足一个易于描述的属性，并且该部分的功能（状态转换）易于描述为单一任务——这将使推理更简单。这些端点属性概括了诸如函数的*前置条件*和*后置条件*，以及循环和类（相对于它们的实例）的*不变量*等概念。努力使各部分尽可能相互独立，可以简化推理，并且在修改这些部分时是必不可少的。

许多众所周知的（尽管可能不太被遵循）被认为是“良好”的编码实践使推理更容易。因此，仅仅是有意推理你的代码，你就已经开始朝着更好的风格和结构思考了。不出所料，这些实践中的大多数可以通过静态代码分析器进行检查：

- 避免使用 `goto` 语句，因为它们会使远程部分高度相互依赖。
- 避免使用可修改的全局变量，因为它们会使所有使用它们的部分相互依赖。
- 每个变量的作用域应尽可能小。例如，可以在首次使用前声明局部对象。
- 在适当的情况下，使对象*不可变*。
- 通过使用水平和垂直间距使代码可读。例如，对齐相关结构并使用空行分隔两个部分。
- 通过为对象、类型、函数等选择描述性（但相对较短）的名称，使代码自文档化。
- 如果需要嵌套部分，将其作为一个函数。
- 使你的函数简短并专注于单一任务。旧的*24行限制*仍然适用。尽管屏幕尺寸和分辨率已经改变，但自20世纪60年代以来，人类的认知能力并没有变化。
- 函数的参数应尽可能少（四个是一个很好的上限）。这并不限制传递给函数的数据：将相关参数分组到一个对象中，可以利用*对象不变量*并节省推理，例如它们的一致性和连贯性。
- 更一般地说，每个代码单元，从代码块到库，都应该有一个*狭窄的接口*。较少的通信减少了所需的推理。这意味着返回内部状态的*getter*是一种负担——不要向对象请求信息来工作。相反，要求对象使用它已有的信息来完成工作。换句话说，*封装*就是——也仅仅是——关于*狭窄的接口*。
- 为了保持类的*不变量*，应避免使用*setter*，因为*setter*往往允许破坏控制对象状态的不变量。

除了推理其正确性外，论证你的代码还能让你更好地理解它。将你获得的见解传达给每个人，以造福所有人。

作者：[Yechiel Kimchi](http://programmer.97things.oreilly.com/wiki/index.php/Yechiel_Kimchi)