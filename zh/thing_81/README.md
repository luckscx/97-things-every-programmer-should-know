# 精确且具体的测试

重要的是测试代码单元所需的、本质的行为，而不是测试其特定实现的偶然行为。但这不应被误解为模糊测试的借口。测试需要既准确又精确。

排序例程是一个经过尝试、测试和验证的经典例子，可以很好地说明这一点。实现排序算法不一定是程序员的日常任务，但排序是一个如此熟悉的概念，以至于大多数人认为他们知道对它的期望。然而，这种随意的熟悉感可能会让人更难看清某些假设。

当程序员被问到“你会测试什么？”时，最常见的回答是“排序的结果是一个有序的元素序列。”虽然这是正确的，但这并不是全部真相。当被要求提供更精确的条件时，许多程序员会补充说，结果序列的长度应与原始序列相同。尽管这是正确的，但这仍然不够。例如，给定以下序列：

```
3 1 4 1 5 9
```

以下序列满足排序后的非递减顺序且长度与原始序列相同的后置条件：

```
3 3 3 3 3 3
```

尽管它满足了规范，但这显然不是我们想要的结果！这个例子基于一个来自实际生产代码的错误（幸运的是在发布前被捕获），其中由于一个简单的按键错误或一时的疏忽，导致了一个复杂的机制，用给定数组的第一个元素填充了整个结果。

完整的后置条件是结果是有序的，并且它包含原始值的一个排列。这适当地约束了所需的行为。结果长度与输入长度相同是自然而然的结果，不需要再重复说明。

即使以后置条件的方式描述也不足以提供一个好的测试。一个好的测试应该是可读的。它应该易于理解且足够简单，以便你可以轻松看出它是否正确（或错误）。除非你已经有了检查序列是否有序以及一个序列是否包含另一个序列的值的排列的代码，否则测试代码很可能会比被测试的代码更复杂。正如 Tony Hoare 所说：

> 有两种构建软件设计的方法：一种方法是让它非常简单，以至于显然没有缺陷；另一种方法是让它非常复杂，以至于没有明显的缺陷。

使用具体的例子可以消除这种偶然的复杂性和出错的机会。例如，给定以下序列：

```
3 1 4 1 5 9
```

排序的结果是：

```
1 1 3 4 5 9
```

没有其他答案可以接受。不接受任何替代品。

具体的例子有助于以易于理解且明确的方式说明一般行为。向空集合添加一个项目的结果不仅仅是集合不为空：而是集合现在有一个项目。并且该项目的值是添加的项目。两个或更多项目将符合不为空的条件。但也是错误的。一个不同值的单个项目也是错误的。向表中添加一行的结果不仅仅是表多了一行。它还意味着可以使用该行的键来恢复添加的行。以此类推。

在指定行为时，测试不应仅仅是准确的：它们还必须是精确的。

作者：[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)