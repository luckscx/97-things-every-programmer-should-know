#精准而具体的测试

重要的是测试代码单元所需的基本行为，而不是测试其特定实现的附带行为。但这不应被视为模糊测试的借口，也不应被误认为是借口。测试既要准确，又要精确。

排序例程提供了一个说明性的例子，这是一个经过测试和测试的经典例程。对于程序员来说，实现排序算法不一定是一项日常任务，但排序是一个如此熟悉的想法，以至于大多数人认为他们知道应该从它得到什么。然而，这种随意的熟悉可能会让人们更难看到过去的某些假设。

当程序员被问到“你会测试什么？”到目前为止，最常见的回答是“排序的结果是元素的排序序列”。虽然这是真的，但这并不是全部事实。当提示输入更精确的条件时，许多程序员补充说，生成的序列应该与原始序列的长度相同。尽管这是正确的，但仍然不够。例如，给定以下序列：

```
3 1 4 1 5 9
```

以下序列满足按非降序排序且长度与原始序列相同的后置条件：

```
3 3 3
```

虽然它满足规范，但它也肯定不是原意！这个例子基于一个来自实际生产代码的错误(幸运的是在它发布之前被发现)，其中一个简单的击键失误或一时的原因失误导致了一种用给定数组的第一个元素填充整个结果的精心设计的机制。

完全后置条件是结果是排序的，并且它包含原始值的排列。这适当地约束了所需的行为。结果长度与输入长度相同，在洗涤时就出来了，不需要重复。

即使以描述的方式描述后置条件，也不足以给您一个好的测试。一个好的测试应该是可读性的。它应该足够容易理解和简单，以便您可以很容易地看出它是正确的(或不正确的)。除非您已经有用于检查序列是否已排序的代码，并且一个序列包含另一个序列中的值的排列，否则测试代码很可能比被测试的代码更复杂。正如托尼·霍尔所说：

>构建软件设计有两种方法：一种是将其简单化，使其*明显*没有缺陷；另一种是将其复杂化，使其没有明显的缺陷。

使用具体的例子消除了这种意外的复杂性和发生事故的机会。例如，给定以下序列：

```
3 1 4 1 5 9
```

排序结果如下：

```
1 1 3 4 5 9
```

没有其他答案可以解决问题。不接受任何替代品。

具体的例子有助于以易于理解和明确的方式说明一般行为。将项添加到空集合的结果不仅仅是它不是空的：而是该集合现在只有一个项。而持有的单个物品就是添加的物品。两个或多个项目将符合非空的条件。而且也将是错误的。一件价值不同的物品也是错误的。向表中添加一行的结果不仅仅是表大了一行。它还需要使用行的键来恢复添加的行。诸若此类。

在指定行为时，测试不应该简单地准确：它们也必须精确。

作者：[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)