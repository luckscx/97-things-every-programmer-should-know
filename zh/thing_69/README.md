# 放下鼠标，远离键盘

你已经连续几个小时专注于某个棘手的问题，但依然找不到解决方案。于是你起身伸展一下腿脚，或者去自动贩卖机买点东西，结果在回来的路上，答案突然变得显而易见。

这种场景听起来熟悉吗？你是否曾想过为什么会这样？关键在于，当你编程时，大脑的逻辑部分处于活跃状态，而创造性的一面则被压制。只有当你让逻辑部分休息时，创造性的一面才能发挥作用。

这里有一个真实的例子：我在清理一些遗留代码时，遇到了一个“有趣”的方法。它的设计目的是验证一个字符串是否包含有效的时间格式 *hh:mm:ss xx*，其中 *hh* 表示小时，*mm* 表示分钟，*ss* 表示秒，*xx* 是 *AM* 或 *PM*。

该方法使用以下代码将两个字符（表示小时）转换为数字，并验证其是否在正确的范围内：

```
try {
    Integer.parseInt(time.substring(0, 2));
} catch (Exception x) {
    return false;
}

if (Integer.parseInt(time.substring(0, 2)) > 12) {
    return false;
}
```

同样的代码又出现了两次，只是字符偏移量和上限值有所变化，用于测试分钟和秒。方法的最后几行代码用于检查是否为 AM 或 PM：

```
if (!time.substring(9, 11).equals("AM") &
    !time.substring(9, 11).equals("PM")) {
    return false;
}
```

如果这一系列比较都没有失败并返回 false，那么方法将返回 true。

如果前面的代码看起来冗长且难以理解，别担心。我也这么认为——这意味着我找到了值得清理的东西。我对其进行了重构，并编写了一些单元测试，以确保它仍然有效。

当我完成后，我对结果感到满意。新版本易于阅读，代码量减少了一半，而且更加准确，因为原始代码只测试了小时、分钟和秒的上限。

第二天准备上班时，我脑海中突然冒出一个想法：为什么不使用正则表达式来验证字符串呢？经过几分钟的敲打，我得到了一个仅有一行代码的工作实现。代码如下：

```
public static boolean validateTime(String time) {
    return time.matches("(0[1-9]|1[0-2]):[0-5][0-9]:[0-5][0-9] ([AP]M)");
}
```

这个故事的重点并不是我最终用一行代码替换了三十多行代码。重点在于，直到我离开电脑，我才意识到我的第一次尝试并不是问题的最佳解决方案。

所以，下次当你遇到一个棘手的问题时，不妨帮自己一个忙。一旦你真正理解了问题，去做一些涉及大脑创造性方面的事情——画出问题的草图，听一些音乐，或者只是出去散散步。有时候，解决问题的最好方法就是放下鼠标，远离键盘。

作者：[BurkHufnagel](http://programmer.97things.oreilly.com/wiki/index.php/BurkHufnagel)