#放下鼠标，远离键盘

你已经专注于一些棘手的问题几个小时了，但看不到解决方案的迹象。所以你站起来伸伸腿，或者去自动售货机，在回来的路上，答案突然变得显而易见。

这种情况听起来熟悉吗？有没有想过为什么会发生这种事？诀窍是，当你在编程时，你大脑的逻辑部分是活跃的，而创造性的一面被拒之门外。它不能向你呈现任何东西，直到逻辑方面休息一下。

这里有一个真实的例子：我在清理一些遗留代码时遇到了一个“有趣”的方法。它旨在使用*hh：mm：ss xx*格式验证字符串是否包含有效的时间，其中*hh*表示小时，*mm*表示分钟，*ss*表示秒，*xx*是*AM*或*PM*。

该方法使用以下代码将两个字符(表示小时)转换为数字，并验证其是否在正确的范围内：

```
试试看{
Integer.parseInt(time.substring(0，2))；
}捕获(异常x){
返回FALSE；
}

If(Integer.parseInt(time.substring(0，2))>12){
返回FALSE；
}
```

相同的代码又出现了两次，并对字符偏移量和上限进行了适当的更改，以测试分钟和秒。该方法以检查AM和PM的代码行结束：

```
如果(！time.substring(9，11).equals(“AM”)&
！time.substring(9，11).equals(“PM”)){
返回FALSE；
}
```

如果这一系列比较均未失败，则返回FALSE，则该方法返回TRUE。

如果前面的代码看起来冗长且难以理解，请不要担心。我也是这么想的--这意味着我找到了一些值得清理的东西。我对它进行了重构，并编写了几个单元测试，以确保它仍然有效。

当我完成时，我对结果感到满意。新版本易于阅读，大小只有原来的一半，而且更准确，因为原始代码只测试了小时、分钟和秒的上限。

第二天准备工作时，我突然想到一个主意：为什么不使用正则表达式来验证字符串呢？在输入几分钟之后，我只用一行代码就有了一个可以工作的实现。它是这样的：

```
公共静态布尔validateTime(字符串时间){
Return time.matches(“(0[1-9]|1[0-2])：[0-5][0-9]：[0-5][0-9]([AP]M)”)；
}
```

这个故事的重点不是我最终只用一行代码替换了三十多行代码。关键是，在我离开电脑之前，我一直认为我的第一次尝试是解决这个问题的最好办法。

所以下次当你遇到麻烦的时候，帮你自己一个忙。一旦你真正了解了问题，就去做一些涉及到你大脑创造性方面的事情--画出问题的草图，听一些音乐，或者只是出去走走。有时候，解决问题的最好办法就是放下鼠标，远离键盘。

作者：[BurkHufnagel](http://programmer.97things.oreilly.com/wiki/index.php/BurkHufnagel)