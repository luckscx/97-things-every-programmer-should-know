#在责备他人之前，请先检查您的代码

开发人员--我们所有人！--经常很难相信我们自己的代码被破坏了。这是如此不可能，这一次，肯定是编译器坏了。

然而，事实上，代码被编译器、解释器、操作系统、应用程序服务器、数据库、内存管理器或任何其他系统软件中的错误破坏是非常(非常)不寻常的。是的，这些漏洞是存在的，但它们远没有我们想象的那么常见。

我曾经遇到过优化循环变量的编译器错误的真正问题，但我曾多次想象我的编译器或操作系统有错误。在这个过程中，我浪费了大量的时间、支持时间和管理时间，但每次最终证明是我的错误时，我都会觉得有点愚蠢。

假设这些工具被广泛使用、成熟，并在各种技术堆栈中使用，那么几乎没有理由怀疑其质量。当然，如果该工具是早期发布的，或者只有几个世界各地的人使用，或者是很少下载的0.1版开源软件的一部分，那么我们可能有充分的理由怀疑该软件。(同样，商业软件的阿尔法版本也可能是可疑的。)

考虑到编译器错误是多么罕见，把时间和精力花在找出代码中的错误上要比证明编译器错误要好得多。所有常见的调试建议都适用，因此请隔离问题、清除调用、用测试包围它；检查调用约定、共享库和版本号；向其他人解释；注意堆栈损坏和变量类型不匹配；在不同的计算机和不同的构建配置(如调试和发布)上尝试代码。

质疑自己的假设和他人的假设。来自不同供应商的工具可能具有不同的内置假设-同一供应商的不同工具也可能具有不同的假设。
当其他人报告你无法复制的问题时，去看看他们在做什么。他们可能正在做一些你从未想过的事情，或者正在以不同的顺序做一些事情。

作为个人规则，如果我有一个错误，我不能确定，我开始认为它是编译器，然后是时候寻找堆栈损坏。如果添加跟踪代码会使问题转移，则情况尤其如此。

多线程问题是导致头发变白并导致机器尖叫的另一个错误来源。当系统是多线程时，所有支持简单代码的建议都会成倍增加。不能依靠调试和单元测试来找到任何一致性的此类错误，因此设计的简单性是最重要的。

因此，在你急于指责编者之前，请记住夏洛克·福尔摩斯的建议：“一旦你排除了不可能的东西，剩下的任何东西，无论多么不可能，都一定是真相，”而不是德克·温特利的建议，“一旦你排除了不可能的东西，剩下的任何东西，无论多么不可能，都一定是真相。”

作者：Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)
