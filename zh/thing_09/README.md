# 在责怪他人之前，先检查你的代码

开发者们——我们所有人！——常常难以相信自己的代码有问题。这太不可能了，这一次一定是编译器出了问题。

然而，事实上，代码因为编译器、解释器、操作系统、应用服务器、数据库、内存管理器或其他系统软件的 bug 而出问题的情况非常（非常）罕见。是的，这些 bug 确实存在，但它们远比我们想象的要少得多。

我曾经确实遇到过编译器优化掉循环变量的 bug，但更多时候是我误以为编译器或操作系统有 bug。在这个过程中，我浪费了大量的时间、支持时间和管理时间，结果每次发现其实是我自己的错误时，都感到有点愚蠢。

如果这些工具被广泛使用、成熟且应用于各种技术栈中，那么就没有太多理由怀疑它们的质量。当然，如果工具是早期版本，或者全球只有少数人在使用，或者是一个很少被下载的 0.1 版本的开源软件，那么怀疑软件有问题可能是合理的。（同样，商业软件的 alpha 版本也可能值得怀疑。）

鉴于编译器 bug 的罕见性，你最好将时间和精力投入到寻找代码中的错误，而不是证明编译器有问题。所有常见的调试建议都适用，因此要隔离问题、剔除调用、用测试包围它；检查调用约定、共享库和版本号；向他人解释问题；注意栈损坏和变量类型不匹配；在不同的机器和不同的构建配置（如调试和发布）上尝试代码。

质疑你自己和他人的假设。来自不同供应商的工具可能有不同的内置假设——同一供应商的不同工具也可能如此。当其他人报告一个你无法复现的问题时，去看看他们在做什么。他们可能在做一些你从未想到的事情，或者以不同的顺序做某事。

作为一个个人规则，如果我有一个无法定位的 bug，并且我开始认为是编译器的问题，那么是时候检查栈损坏了。如果添加跟踪代码使问题发生变化，这一点尤其正确。

多线程问题是另一个让人抓狂的 bug 来源。当系统是多线程时，所有倾向于简单代码的建议都被放大了。调试和单元测试不能指望一致地发现此类 bug，因此设计的简单性至关重要。

所以，在你急于责怪编译器之前，记住夏洛克·福尔摩斯的建议：“当你排除了所有不可能的情况后，剩下的无论多么不可思议，都一定是真相。” 并优先考虑它，而不是德克·根特的建议：“当你排除了所有不可思议的情况后，剩下的无论多么不可能，都一定是真相。”

作者：[Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)