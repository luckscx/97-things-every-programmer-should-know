#封装行为，而不仅仅是状态

在系统论中，包容是处理大型复杂系统结构时最有用的概念之一。在软件行业中，包容或封装的价值是众所周知的。包容由编程语言构造支持，如子例程和函数、模块和包、类等。

模块和包解决了更大规模的封装需求，而类、子例程和函数则解决了更细粒度的问题。多年来，我发现类似乎是开发人员最难正确处理的封装构造之一。有一个只有3000行main方法的类，或者只有*set*和*get*方法作为基本属性的类并不少见。这些例子表明，所涉及的开发人员没有完全理解面向对象的思想，没有充分利用对象作为建模构造的力量。对于熟悉POJO(普通旧Java对象)和POCO(普通旧C#对象或普通旧CLR对象)这两个术语的开发人员来说，这是为了回到OO作为建模范例的基础上--对象简单而简单，但不是愚蠢的。

对象同时封装状态和行为，其中行为由实际状态定义。考虑一个门对象。它有四种状态：关闭、打开、关闭、打开。它提供两种操作：打开和关闭。根据状态的不同，打开和关闭操作的行为也不同。对象的这种固有属性使设计过程在概念上变得简单。它归结为两个简单的任务：将责任分配和委派给不同的对象，包括对象间交互协议。

这在实践中是如何工作的，用一个例子来说明是最好的。假设我们有三个类：Customer、Order和Item。客户对象是信用额度和信用验证规则的自然占位符。Order对象知道其关联的客户，其addItem操作通过调用`Customer.validateCredit(item.Price())`委托实际的信用检查。如果该方法的后置条件失败，则会引发异常并中止购买。

经验较少的面向对象开发人员可能会决定将所有业务规则包装到一个通常称为`OrderManager‘或`OrderService`的对象中。在这些设计中，`Order`、`Customer`和`Item`被视为记录类型。所有逻辑都从类中分离出来，并在一个大型的过程性方法中绑定在一起，该方法带有许多内部的*If-Then-Else*构造。这些方法很容易被破坏，而且几乎不可能维护。原因呢？封装已损坏。

因此，最后，不要破坏封装，并使用编程语言的强大功能来维护它。

作者：[Eina Landre](http://programmer.97things.oreilly.com/wiki/index.php/Einar_Landre)