#抵制单件模式的诱惑

Singleton模式解决了您的许多问题。您知道您只需要一个实例。您可以保证在使用该实例之前对其进行初始化。它拥有全球接入点，让您的设计变得简单。一切都很好。这个经典的设计模式有什么不好的地方呢？

事实证明，这是相当多的。他们可能很诱人，但经验表明，大多数单身人士实际上弊大于利。它们阻碍了可测试性并损害了可维护性。不幸的是，这一额外的智慧并没有像它应该得到的那样广泛传播，单身人士继续对许多程序员具有不可抗拒的吸引力。但这是值得抵制的：

-单实例需求经常被想象出来。在许多情况下，纯粹是猜测未来不需要额外的实例。在应用程序的设计中传播这样的投机性属性在某一时刻必然会带来痛苦。要求将会改变。好的设计接受了这一点。单身人士则不会。

-单例会导致概念上独立的代码单元之间的隐式依赖关系。这是有问题的，因为它们是隐藏的，也因为它们在单元之间引入了不必要的耦合。当您尝试编写单元测试时，这种代码气味会变得刺鼻，因为单元测试依赖于松散耦合以及有选择地用模拟实现替换真实实现的能力。单身人士避免了这种直截了当的嘲弄。

-单例还携带隐式持久化状态，这再次阻碍了单元测试。单元测试依赖于相互独立的测试，因此测试可以以任何顺序运行，并且可以在执行每个单元测试之前将程序设置为已知状态。一旦引入了状态可变的单例，这可能很难实现。此外，这种全局可访问的持久状态使得对代码进行推理变得更加困难，尤其是在多线程环境中。

-多线程给单例模式带来了更多的陷阱。由于直接锁定访问并不是很有效，所以所谓的双重检查锁定模式(DCLP)变得流行起来。不幸的是，这可能是另一种致命的吸引力。事实证明，在许多语言中，DCLP不是线程安全的，即使在哪里，仍然有可能出现细微的错误。

清理单身人士可能是最后一个挑战：

-不支持明确杀死单身人士，这在某些情况下可能是一个严重的问题。例如，在插件体系结构中，只有在清除了插件的所有对象之后，才能安全地卸载插件。

-程序退出时对单例的隐式清除没有顺序。对于包含具有相互依赖关系的单例的应用程序来说，这可能很麻烦。当关闭这类应用程序时，一个单例可能会访问另一个已经被破坏的单例。

-其中一些缺点可以通过引入额外的机制来克服。然而，这是以代码的额外复杂性为代价的，而这些代码本来可以通过选择替代设计来避免。

因此，将Singleton模式的使用限制在必须实例化一次以上的类。不要在任意代码中使用单例的全局访问点。相反，对单例的直接访问应该只从几个定义良好的位置进行，在那里它可以通过它的接口传递到其他代码。其他代码是不知道的，因此不依赖于是单例类还是任何其他类型的类实现该接口。这打破了阻碍单元测试的依赖关系，并提高了可维护性。因此，下次当您考虑实现或访问单例时，希望您会停下来，三思。

作者：[Sam Saariste](http://programmer.97things.oreilly.com/wiki/index.php/Sam_Saariste)