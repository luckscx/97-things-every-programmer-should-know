# 抵制单例模式的诱惑

单例模式解决了许多问题。你知道你只需要一个实例。你保证这个实例在使用前已被初始化。它通过提供一个全局访问点来保持设计的简洁。这一切都很好。这个经典的设计模式有什么不讨人喜欢的地方呢？

事实上，问题很多。尽管单例模式可能很诱人，但经验表明，大多数单例模式实际上弊大于利。它们阻碍了可测试性，损害了可维护性。不幸的是，这种额外的智慧并没有像它应该的那样广泛传播，单例模式对许多程序员来说仍然具有不可抗拒的吸引力。但值得抵制：

- 单实例的需求往往是想象出来的。在许多情况下，未来不需要额外实例的假设纯粹是推测。在应用程序设计中传播这种推测性的属性，必然会在某个时候带来痛苦。需求会发生变化。好的设计会拥抱这种变化。单例模式则不会。

- 单例模式在概念上独立的代码单元之间引入了隐式依赖关系。这之所以有问题，是因为它们既隐藏了依赖关系，又在单元之间引入了不必要的耦合。当你尝试编写单元测试时，这种代码异味会变得尤为明显，因为单元测试依赖于松耦合以及能够选择性地用模拟实现替换真实实现。单例模式阻止了这种直接的模拟。

- 单例模式还带有隐式的持久状态，这同样阻碍了单元测试。单元测试依赖于测试之间的独立性，因此测试可以以任何顺序运行，并且在每个单元测试执行之前，程序可以设置为已知状态。一旦你引入了带有可变状态的单例模式，这可能就很难实现。此外，这种全局可访问的持久状态使得代码更难理解，尤其是在多线程环境中。

- 多线程进一步加剧了单例模式的陷阱。由于在访问时直接锁定效率不高，所谓的双重检查锁定模式（DCLP）变得流行起来。不幸的是，这可能是一种更具致命吸引力的形式。事实证明，在许多语言中，DCLP 并不是线程安全的，即使在某些语言中是线程安全的，仍然有可能在细微之处出错。

单例模式的清理可能会带来最后的挑战：

- 没有明确支持销毁单例模式，这在某些情况下可能是一个严重的问题。例如，在插件架构中，只有在所有对象都被清理后，插件才能安全卸载。

- 在程序退出时，单例模式的隐式清理没有顺序。这对于包含相互依赖的单例模式的应用程序来说可能会很麻烦。在关闭此类应用程序时，一个单例模式可能会访问另一个已经被销毁的单例模式。

- 通过引入额外的机制可以克服其中一些缺点。然而，这会以增加代码复杂性为代价，而这种复杂性本可以通过选择替代设计来避免。

因此，请将单例模式的使用限制在那些真正只能实例化一次的类上。不要从任意代码中使用单例模式的全局访问点。相反，对单例模式的直接访问应该仅限于少数明确定义的地方，从这些地方可以通过其接口将单例模式传递给其他代码。这些其他代码并不知道单例模式的存在，因此也不依赖于单例模式或任何其他类是否实现了该接口。这打破了阻碍单元测试的依赖关系，并提高了可维护性。所以，下次你考虑实现或访问单例模式时，希望你能够停下来，再想一想。

作者：[Sam Saariste](http://programmer.97things.oreilly.com/wiki/index.php/Sam_Saariste)