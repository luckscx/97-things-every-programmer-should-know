# 链接器并不是一个神奇的程序

令人沮丧的是（就在我写这篇文章之前，这种情况又发生在我身上），许多程序员对从源代码到编译语言中的静态链接可执行文件的过程的看法是：

1. 编辑源代码
2. 将源代码编译成目标文件
3. 发生了一些神奇的事情
4. 运行可执行文件

当然，第3步就是链接步骤。为什么我会说这么离谱的话？我已经做了几十年的技术支持，并且一次又一次地收到以下问题：

- 链接器说 `def` 被多次定义。
- 链接器说 `abc` 是一个未解析的符号。
- 为什么我的可执行文件这么大？

接着通常是“我现在该怎么办？”通常伴随着“似乎”和“不知怎么的”这样的短语，以及一种完全困惑的氛围。正是“似乎”和“不知怎么的”表明链接过程被视为一个神奇的过程，大概只有巫师和术士才能理解。编译过程并不会引发这些短语，这意味着程序员通常理解编译器的工作原理，或者至少知道它们做了什么。

链接器是一个非常愚蠢、平凡、直接的程序。它所做的一切就是将目标文件的代码和数据段连接在一起，将符号的引用与其定义连接起来，从库中提取未解析的符号，并写出一个可执行文件。就是这样。没有咒语！没有魔法！编写链接器的繁琐之处通常在于解码和生成通常极其复杂的文件格式，但这并不会改变链接器的本质。

所以，假设链接器说 `def` 被多次定义。许多编程语言，如C、C++和D，都有声明和定义。声明通常放在头文件中，比如：

```
extern int iii;
```

这会生成对符号 `iii` 的外部引用。另一方面，定义实际上为符号分配了存储空间，通常出现在实现文件中，看起来像这样：

```
int iii = 3;
```

每个符号可以有多少个定义？就像电影《高地人》中一样，只能有一个。那么，如果 `iii` 的定义出现在多个实现文件中会发生什么？

```
// 文件 a.c
int iii = 3;
```

```
// 文件 b.c
double iii(int x) { return 3.7; }
```

链接器会抱怨 `iii` 被多次定义。

不仅只能有一个定义，而且必须有一个定义。如果 `iii` 只作为声明出现，但从未定义过，链接器会抱怨 `iii` 是一个未解析的符号。

要确定可执行文件的大小，可以查看链接器可选生成的映射文件。映射文件只不过是可执行文件中所有符号及其地址的列表。这告诉你从库中链接了哪些模块，以及每个模块的大小。现在你可以看到膨胀来自哪里。通常会有一些库模块，你根本不知道为什么它们会被链接进来。要弄清楚这一点，可以暂时从库中移除可疑的模块，然后重新链接。生成的未定义符号错误将指示谁在引用该模块。

尽管有时并不立即明显为什么你会得到特定的链接器消息，但链接器并没有什么神奇之处。机制是直接的；你只需要在每种情况下弄清楚细节。

作者：[Walter Bright](http://creativecommons.org/licenses/by/3.0/us/)