#链接器不是神奇的程序

令人沮丧的是(就在我写这篇文章之前，又发生在我身上)，许多程序员对用编译语言从源代码转换为静态链接可执行文件的过程的看法是：

1.编辑源代码
2.将源代码编译成目标文件
3.发生了一些神奇的事情
4.运行可执行文件

当然，第三步是链接步骤。我为什么要说这么离谱的话呢？我已经做了几十年的技术支持，我一次又一次地收到以下问题：

-链接器表示定义了不止一次。
-链接器说ABC是一个未解析的符号。
-为什么我的可执行文件这么大？

紧随其后的是“我现在怎么办？”通常夹杂着“似乎”和“不知何故”的短语，以及一种完全不知所措的光环。“似乎”和“不知何故”表明，链接过程被视为一个神奇的过程，大概只有巫师和术士才能理解。编译的过程不会引出这类短语，这意味着程序员通常了解编译器是如何工作的，或者至少了解它们做了什么。

链接器是一个非常愚蠢、平淡无奇、简单明了的程序。它所做的只是将目标文件的代码部分和数据部分连接在一起，将对符号的引用与它们的定义联系起来，从库中取出未解析的符号，并写出可执行文件。就这样。没有咒语！没有魔法！编写链接器的单调乏味通常都是关于解码和生成通常非常复杂的文件格式，但这并不会改变链接器的本质。

假设链接器说def被定义了不止一次。许多编程语言，如C、C++和D，都有声明和定义。声明通常放入头文件中，如：

```
外部INT III；
```

它生成对符号`iii`的外部引用。另一方面，定义实际上为符号预留了存储空间，通常出现在实现文件中，如下所示：

```
INT III=3；
```

每个符号可以有多少个定义？就像在电影《高地人》中一样，只能有一个。那么，如果III的定义出现在多个实现文件中，该怎么办呢？

```
//文件A.C
INT III=3；
```

```
//文件B.C
Double III(Int X){返回3.7；}
```

链接器会抱怨`ill‘被多重定义。

不仅只能有一个，而且必须有一个。如果III只作为一个声明出现，而不是一个定义，链接器会抱怨III是一个未解析的符号。

要确定可执行文件的大小为何如此大，请查看链接器可选生成的映射文件。映射文件只不过是可执行文件中所有符号及其地址的列表。这将告诉您从库中链接了哪些模块，以及每个模块的大小。现在你可以看到肿胀是从哪里来的了。通常会有一些库模块，您不知道为什么要链接它们。要解决此问题，请暂时从库中移除可疑模块，然后重新链接。然后生成的未定义符号错误将指示谁在引用该模块。

虽然并不总是一眼就能看出为什么您会收到特定的链接器消息，但链接器并没有什么神奇之处。机制很简单；这是你必须在每种情况下弄清楚的细节。

作者：[Walter Bright](http://creativecommons.org/licenses/by/3.0/us/)
