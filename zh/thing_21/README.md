#区分业务异常和技术异常

在运行时出错基本上有两个原因：阻止我们使用应用程序的技术问题和阻止我们误用应用程序的业务逻辑。大多数现代语言，如LISP、Java、SmallTalk和C#，都使用异常来通知这两种情况。然而，这两种情况是如此不同，应该小心地分开。使用相同的异常层次结构来表示它们是潜在的混淆来源，更不用说相同的异常类了。

当存在编程错误时，可能会出现无法解决的技术问题。例如，如果您试图从一个大小为17的数组访问元素83，那么程序显然偏离了轨道，应该会出现一些异常。更微妙的版本正在使用不适当的参数调用一些库代码，从而在库内部导致相同的情况。

试图解决你自己造成的这些情况将是错误的。相反，我们让异常冒泡到最高体系结构级别，并让一些通用的异常处理机制尽其所能确保系统处于安全状态，例如回滚事务、记录和警告管理，以及(礼貌地)向用户报告。

这种情况的一种变体是，当您处于“库情况”时，调用者违反了方法的约定，例如，传递了一个完全奇怪的参数或没有正确设置依赖对象。这等同于从17开始访问第83个元素：调用者应该检查；不这样做是程序员在客户端的错误。正确的回应是抛出一个技术异常。

另一种不同但仍然是技术上的情况是，程序由于执行环境中的问题而无法继续执行，例如没有响应的数据库。在这种情况下，您必须假设基础设施尽其所能来解决这种情况-修复连接并重试合理的次数-但失败了。即使原因不同，调用代码的情况也是相似的：它对此几乎无能为力。因此，我们通过一个异常来通知这种情况，让Buid上升到一般的异常处理机制。

与此形成对比的是，我们遇到的情况是，由于域逻辑原因无法完成调用。在这种情况下，我们遇到了一种例外情况，即不寻常和不受欢迎的情况，但并不奇怪或编程错误。例如，如果我试图从一个资金不足的账户中提取资金。换句话说，这种情况是合同的一部分，抛出异常只是模型的一部分，客户应该意识到并准备好处理。对于这些情况，创建特定的异常或单独的异常层次结构是合适的，以便客户端可以根据自己的条件处理这种情况。

在同一层次结构中混合技术异常和业务异常模糊了区别，并使调用者对什么是方法契约、调用前需要确保什么条件以及应该处理什么情况感到困惑。将案例分离可以使情况更清晰，并增加技术异常将由某个应用程序框架处理的可能性，而业务域异常实际上是由客户端代码考虑和处理的。

作者：[Dan Bergh Johnsson](http://programmer.97things.oreilly.com/wiki/index.php/Dan_Bergh_Johnsson)