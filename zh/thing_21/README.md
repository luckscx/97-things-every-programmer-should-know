# 区分业务异常与技术异常

在运行时，事情出错的原因基本上有两种：阻止我们使用应用程序的技术问题和阻止我们误用应用程序的业务逻辑。大多数现代语言，如LISP、Java、Smalltalk和C#，都使用异常来通知这两种情况。然而，这两种情况是如此不同，应该仔细区分开来。使用相同的异常层次结构（更不用说相同的异常类）来表示它们，可能会导致混淆。

当存在编程错误时，可能会出现无法解决的技术问题。例如，如果你尝试从大小为17的数组中访问第83个元素，那么程序显然偏离了轨道，应该抛出某种异常。更微妙的情况是使用不适当的参数调用某些库代码，导致库内部出现相同的情况。

试图解决你自己造成的这些情况是错误的。相反，我们让异常冒泡到最高的架构层次，并让一些通用的异常处理机制尽其所能确保系统处于安全状态，例如回滚事务、记录日志并通知管理员，以及（礼貌地）向用户报告。

这种情况的一个变体是当你处于“库情境”中，调用者破坏了你的方法契约，例如传递了一个完全奇怪的参数或没有正确设置依赖对象。这与从17个元素中访问第83个元素相当：调用者应该进行检查；不这样做是客户端程序员的错误。正确的响应是抛出一个技术异常。

另一种仍然是技术性的情况是，由于执行环境中的问题（例如无响应的数据库），程序无法继续执行。在这种情况下，你必须假设基础设施已经尽其所能解决问题——修复连接并重试合理的次数——但失败了。即使原因不同，调用代码的情况也是相似的：它对此无能为力。因此，我们通过一个异常来通知这种情况，并让它冒泡到通用的异常处理机制。

与这些情况相反，我们有一种情况是你由于领域逻辑原因无法完成调用。在这种情况下，我们遇到了一种异常情况，即不寻常且不希望的，但并不奇怪或程序上有错误。例如，如果我尝试从一个资金不足的账户中取款。换句话说，这种情况是契约的一部分，抛出异常只是模型中的一种*替代返回路径*，客户端应该意识到并准备好处理。对于这些情况，创建特定的异常或单独的异常层次结构是合适的，以便客户端可以根据自己的条件处理这种情况。

将技术异常和业务异常混合在同一个层次结构中会模糊区别，并使调用者混淆方法的契约是什么，调用前需要确保什么条件，以及应该处理什么情况。区分这些情况可以提供清晰性，并增加技术异常由某些应用程序框架处理的机会，而业务领域异常实际上由客户端代码考虑和处理。

作者：[Dan Bergh Johnsson](http://programmer.97things.oreilly.com/wiki/index.php/Dan_Bergh_Johnsson)