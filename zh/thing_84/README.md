# 状态思维

现实世界中的人们与状态有着一种奇怪的关系。今天早上，我路过当地的一家商店，准备为将咖啡因转化为代码的又一天做准备。由于我最喜欢的方式是喝拿铁咖啡，而我找不到任何牛奶，于是我问了店员。

“抱歉，我们的牛奶超级、超级缺货。”

对于程序员来说，这是一个奇怪的陈述。你要么有牛奶，要么没有。在缺货的情况下，没有程度之分。也许她试图告诉我他们将缺货一周，但结果是一样的——对我来说是浓缩咖啡日。

在大多数现实世界的情况下，人们对状态的放松态度并不是问题。然而，不幸的是，许多程序员对状态也非常模糊——这是一个问题。

考虑一个只接受信用卡且不为客户开具发票的简单网店，其中有一个包含以下方法的 `Order` 类：

```
 public boolean isComplete() {
     return isPaid() && hasShipped();
 }
```

合理，对吧？好吧，即使这个表达式被很好地提取到一个方法中，而不是到处复制粘贴，这个表达式也不应该存在。它的存在突显了一个问题。为什么？因为订单在付款之前不能发货。因此，除非 `isPaid` 为真，否则 `hasShipped` 不能为真，这使得表达式的一部分变得多余。你可能仍然希望 `isComplete` 在代码中更清晰，但它应该看起来像这样：

```
 public boolean isComplete() {
     return hasShipped();
 }
```

在我的工作中，我经常看到遗漏的检查和冗余的检查。这个例子很小，但当你添加取消和退款时，它会变得更加复杂，良好的状态处理需求也会增加。在这种情况下，订单只能处于三种不同的状态之一：

- *进行中：* 可以添加或删除商品。不能发货。
- *已付款：* 不能添加或删除商品。可以发货。
- *已发货：* 完成。不再接受更改。

这些状态很重要，你需要在执行操作之前检查你是否处于预期状态，并且你只能从当前状态移动到合法状态。简而言之，你必须在正确的地方小心地保护你的对象。

但你如何开始思考状态呢？将表达式提取为有意义的方法是一个非常好的开始，但这只是一个开始。基础是理解状态机。我知道你可能在计算机科学课上留下了不好的回忆，但把它们抛在脑后。状态机并不特别难。将它们可视化，使它们易于理解和讨论。通过测试驱动你的代码来揭示有效和无效的状态和转换，并保持它们的正确性。研究状态模式。当你感到舒适时，阅读契约设计。它通过在每个公共方法的入口和出口验证传入的数据和对象本身，帮助你确保有效状态。

如果你的状态不正确，那就是一个错误，如果你不中止，你就有可能破坏数据。如果你发现状态检查是噪音，学习如何使用工具、代码生成、编织或切面来隐藏它们。无论你选择哪种方法，状态思维都会使你的代码更简单、更健壮。

作者：[Niclas Nilsson](http://programmer.97things.oreilly.com/wiki/index.php/Niclas_Nilsson)