# 两个错误可以造就一个正确（并且难以修复）

代码从不说谎，但它可能会自相矛盾。有些矛盾会导致那些“这怎么可能工作？”的时刻。

在一次[采访](http://www.netjeff.com/humor/item.cgi?file=ApolloComputer)中，阿波罗11号登月舱软件的首席设计师Allan Klumpp透露，控制引擎的软件中存在一个本应使着陆器不稳定的错误。然而，另一个错误弥补了第一个错误，因此在发现或修复这两个错误之前，该软件被用于阿波罗11号和12号的登月任务。

考虑一个返回完成状态的函数。想象一下，它在本应返回true时返回了false。现在想象一下，调用函数忽略了检查返回值。一切正常，直到有一天有人注意到缺少检查并插入了它。

或者考虑一个将状态存储为XML文档的应用程序。想象一下，其中一个节点被错误地写为`TimeToLive`，而不是文档中所说的`TimeToDie`。当写入代码和读取代码都包含相同的错误时，一切看起来都很好。但是修复其中一个，或者添加一个读取同一文档的新应用程序，对称性就被打破了，代码也随之出现问题。

当代码中的两个缺陷导致一个可见的故障时，系统化的故障修复方法本身可能会失效。开发者收到一个错误报告，找到缺陷，修复它，并重新测试。然而，报告的故障仍然存在，因为第二个缺陷在起作用。因此，第一个修复被撤销，代码被检查直到找到第二个潜在缺陷，并应用修复。但第一个缺陷又回来了，报告的故障仍然存在，因此第二个修复被回滚。这个过程重复进行，但现在开发者已经排除了两个可能的修复方案，并正在寻找一个永远不会起作用的第三个方案。

两个代码缺陷之间的相互作用表现为一个可见的故障，这不仅使问题难以修复，还会让开发者走入死胡同，最终发现他们早先尝试的解决方案是正确的。

这种情况不仅发生在代码中：问题也存在于书面需求文档中。而且它可以像病毒一样从一个地方传播到另一个地方。代码中的错误弥补了书面描述中的错误。

它也可以传播到人身上：用户学会了当应用程序说“左”时意味着“右”，因此他们相应地调整自己的行为。他们甚至将其传递给新用户：“记住，当那个应用程序说点击左键时，它实际上是指右边的按钮。”修复错误后，突然之间用户需要重新培训。

单一的错误可能很容易发现和修复。那些由多个原因引起、需要多次更改的问题则更难解决。部分原因是简单的问题很容易修复，以至于人们倾向于相对快速地解决它们，而将更困难的问题留到以后解决。

关于如何处理由相互关联的缺陷引起的故障，没有简单的建议。需要意识到这种可能性，保持清醒的头脑，并愿意考虑所有可能性。

作者：[Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)