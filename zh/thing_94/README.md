# 使用示例编写小型函数

我们希望编写正确的代码，并且手头有证据证明其正确性。思考函数的“大小”有助于解决这两个问题。这里的“大小”并不是指实现函数的代码量——尽管这也很重要——而是指我们的代码所体现的数学函数的大小。

例如，在围棋游戏中，有一种情况叫做*打吃*（atari），即一方的棋子可能会被对手捕获：如果一个棋子有两个或更多的自由空间（称为*气*），那么它就不处于打吃状态。计算一个棋子有多少气可能比较复杂，但如果知道了气的数量，判断是否处于打吃状态就很简单了。我们可能会从编写这样的函数开始：

```
boolean atari(int libertyCount)
    libertyCount < 2
```

这个函数比看起来要大。数学函数可以理解为一个集合，它是其定义域（这里是`int`）和值域（这里是`boolean`）的笛卡尔积的某个子集。如果这些值的集合与Java中的大小相同，那么集合`int×boolean`中将有`2L*(Integer.MAX_VALUE+(-1L*Integer.MIN_VALUE)+1L)`或8,589,934,592个成员。其中一半是我们函数的子集成员，因此为了提供完整的证据证明我们的函数是正确的，我们需要检查大约4.3×10<sup>9</sup>个示例。

这就是测试无法证明没有bug的本质。测试可以展示功能的存在，但我们仍然面临这个大小的问题。

问题领域帮助我们解决了这个问题。围棋的性质意味着一个棋子的气数并不是任意的整数，而是{1,2,3,4}中的一个。因此，我们可以这样写：

```
LibertyCount = {1,2,3,4} 
boolean atari(LibertyCount libertyCount)
    libertyCount == 1
```

这样处理起来就容易多了：现在计算的函数是一个最多有八个成员的集合。事实上，四个检查过的示例就足以完全确定函数是正确的。这就是为什么使用与问题领域密切相关的类型来编写程序，而不是使用原生类型，是一个好主意。使用受领域启发的类型通常可以使我们的函数变得更小。找出这些类型应该是什么的一种方法是在编写函数之前，以问题领域的术语找出要检查的示例。

作者：[Keith Braithwaite](http://programmer.97things.oreilly.com/wiki/index.php/Keith_Braithwaite)