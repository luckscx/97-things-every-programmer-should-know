#使用示例编写小函数

我们想写的代码是正确的，并有证据表明它是正确的。考虑函数的“大小”可以帮助解决这两个问题。不是指实现函数的代码量--尽管这很有趣--而是我们的代码所显示的数学函数的大小。

例如，在围棋中，有一种情况称为*Atari*，在这种情况下，棋手的棋子可能会被对手捕获：一块有两个或更多自由空间的棋子(称为*自由*)不在Atari中。要计算一块石头有多少自由可能很棘手，但如果知道这一点，确定雅达利很容易。我们可以从编写如下所示的函数开始：

```
Boolean Atari(Int LibertyCount)
LibertyCount<2
```

这比看上去的要大。数学函数可以被理解为一个集合，即集合的笛卡尔乘积的某个子集，这些集合是它的定义域(这里是‘int`)和值域(这里是’boolan‘)。如果这些值集与JAVA中的值大小相同，那么在集合``2L*(Integer.MAX_VALUE+(-1L*Integer.MIN_VALUE)+1L)`×boolan`中将有int或8,589,934,592个成员。其中一半是我们的函数子集的成员，因此要提供完整的证据证明我们的函数是正确的，我们需要检查大约4.3x10<sup>9</sup>示例。

这就是测试不能证明没有错误的说法的实质。不过，测试可以证明这些功能的存在。但我们仍然有这个大小的问题。

问题域帮助我们解决问题。围棋的性质意味着，一块石头的自由度不是任何整数，而恰好是{1，2，3，4}中的一个。因此，我们也可以这样写：

```
LibertyCount={1，2，3，4}
Boolean Atari(LibertyCount LibertyCount)
LibertyCount==1
```

这要容易得多：计算的函数现在是一个最多有八个成员的集合。事实上，四个选中的例子将构成完全确定该函数是正确的证据。这就是为什么使用与问题域密切相关的类型而不是本机类型来编写程序是一个好主意。使用域启发类型通常可以使我们的函数变得小得多。要找出这些类型应该是什么，一种方法是在编写函数之前找到检入问题领域术语的示例。

作者：Keith Braithwaite](http://programmer.97things.oreilly.com/wiki/index.php/Keith_Braithwaite)