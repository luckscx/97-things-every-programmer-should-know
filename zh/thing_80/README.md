# 测试必要行为，而非偶然行为

测试中的一个常见陷阱是假设实现所做的正是你想要测试的内容。乍一听，这似乎更像是一种美德而非陷阱。然而，换一种说法，问题就更加明显了：测试中的一个常见陷阱是将测试硬编码到实现的具体细节中，而这些细节是偶然的，与所需功能无关。

当测试与实现的偶然细节硬编码在一起时，对实现所做的实际上与所需行为兼容的更改可能会导致测试失败，从而导致误报。程序员通常的反应是重写测试或重写代码。假设误报实际上是真正的正报，通常是恐惧、不确定性或怀疑的结果。这会将偶然行为提升为必要行为。在重写测试时，程序员要么将测试重新聚焦于所需行为（好的做法），要么简单地将其硬编码到新的实现中（不好的做法）。测试需要足够精确，但也需要准确。

例如，在三向比较中，如C语言的`strcmp`或Java的`String.compareTo`，对结果的要求是：如果左侧小于右侧，则结果为负；如果左侧大于右侧，则结果为正；如果它们被视为相等，则结果为零。这种比较风格用于许多API中，包括C语言`qsort`函数的比较器和Java`Comparable`接口中的`compareTo`。尽管在实现中通常使用特定值`-1`和`+1`分别表示*小于*和*大于*，但程序员常常错误地认为这些值代表了实际要求，并因此编写测试来公开这一假设。

类似的问题也出现在断言间距、精确措辞以及其他文本格式化和呈现方面的测试中，这些方面都是偶然的。除非你在编写例如提供可配置格式化的XML生成器，否则间距对结果不应有影响。同样，将按钮和标签的位置硬编码到UI控件中会减少未来更改和完善这些偶然细节的选项。实现中的微小更改和格式上的无关紧要的更改突然成为构建破坏者。

过度指定的测试通常是单元测试中白盒方法的一个问题。白盒测试使用代码的结构来确定所需的测试用例。白盒测试的典型失败模式是测试最终断言代码做了代码所做的事情。简单地重复代码中已经显而易见的内容并没有增加价值，反而会导致一种虚假的进展感和安全感。

为了有效，测试需要陈述契约义务，而不是鹦鹉学舌地重复实现。它们需要对被测单元采取黑盒视角，以可执行的形式勾勒出接口契约。因此，将测试行为与所需行为对齐。

作者：[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)