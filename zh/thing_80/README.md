#测试必需的行为，而不是附带行为

测试中的一个常见陷阱是假设实现所做的正是您想要测试的。乍一看，这听起来更像是一种美德，而不是陷阱。然而，换一种方式来说，问题变得更加明显：测试中的一个常见陷阱是将测试硬连接到实现的细节，其中这些细节是偶然的，与所需的功能无关。

当测试硬连接到实现附带内容时，对实现的更改实际上与所需的行为兼容，可能会导致测试失败，从而导致误报。程序员通常通过重写测试或重写代码来响应。假设假阳性实际上是真阳性通常是恐惧、不确定或怀疑的结果。它的效果是将附带行为的地位提高到必要的行为。在重写测试时，程序员要么将测试重新集中在所需的行为上(好的)，要么简单地将其硬连接到新的实现上(不好的)。测试需要足够精确，但它们也需要准确。

例如，在三向比较中，例如C的`strcmp`或Java的`String.CompareTo`，对结果的要求是：如果左侧小于右侧，则为负；如果左侧大于右侧，则为正；如果左侧大于右侧，则为零。这种比较风格在许多接口中都有使用，包括C的`qsort`函数的比较器和Java的`Compable`接口中的`CompareTo`。虽然在实现中通常使用特定值`-1`和`+1`来表示*小于*和*大于*，但程序员经常错误地假设这些值代表实际需求，并因此编写测试来公开证明这一假设。

断言间距、精确措辞以及文本格式和表示的其他附带方面的测试也会出现类似的问题。例如，除非您正在编写一个提供可配置格式的XML生成器，否则空格对结果应该不重要。同样，在UI控件上硬连接按钮和标签的位置减少了将来更改和改进这些附带内容的选项。实现上的微小更改和格式上的无关紧要的更改突然成为构建的破坏者。

指定过多的测试通常是单元测试的白盒方法的一个问题。白盒测试使用代码的结构来确定所需的测试用例。白盒测试的典型失败模式是，测试最终断言代码做了代码做的事情。简单地重复代码中已经显而易见的东西不会增加任何价值，并会导致错误的进度和安全感。

为了有效，测试需要声明合同义务，而不是鹦鹉般的实现。他们需要对测试中的单元进行黑箱操作，以可执行的形式勾勒出接口契约。因此，应将测试的行为与所需的行为对齐。

作者：[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)